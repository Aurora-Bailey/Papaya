{
  "rules": {
    "user": {
      "$uid": {
        // Allow user to access data they own
        ".read": "auth.uid == $uid",

        // Validate inputs
        "locationName": { ".write": "auth.uid == $uid && newData.exists()", ".validate": "newData.isString() && newData.val().length <= 120" },
        "locationLong": { ".write": "auth.uid == $uid && newData.exists()", ".validate": "newData.isNumber() && newData.val() <= 180 && newData.val() >= -180" },
        "locationLat": { ".write": "auth.uid == $uid && newData.exists()", ".validate": "newData.isNumber() && newData.val() <= 90 && newData.val() >= -90" },
        "displayName": { ".write": "auth.uid == $uid && newData.exists()", ".validate": "newData.isString() && newData.val().length <= 120" },
        "pictureURL": { ".write": "auth.uid == $uid && newData.exists()", ".validate": "newData.isString() && newData.val().length <= 250 && newData.val().matches(/^https:\\/\\/firebasestorage.googleapis.com\\//i) || newData.val().length == 0" },
        "firstName": { ".write": "auth.uid == $uid && newData.exists()", ".validate": "newData.isString() && newData.val().length <= 60" },
        "lastName": { ".write": "auth.uid == $uid && newData.exists()", ".validate": "newData.isString() && newData.val().length <= 60" },
        "distance": { ".write": "auth.uid == $uid && newData.exists()", ".validate": "newData.isNumber() && newData.val() <= 100 && newData.val() >= 1" },
        "birthday": { ".write": "auth.uid == $uid && newData.exists()", ".validate": "newData.isNumber() && newData.val() <= now && newData.val() >= -5364662000000" },
        // Tighter security, but prevents email change,
        //"email": { ".write": "auth.uid == $uid && newData.exists()", ".validate": "auth.token.email == newData.val() || auth.email == newData.val()" },
        "email": { ".write": "auth.uid == $uid && newData.exists()", ".validate": "newData.isString() && newData.val().length <= 250" },
        "bio": { ".write": "auth.uid == $uid && newData.exists()", ".validate": "newData.isString() && newData.val().length <= 500" },
        "sex": { ".write": "auth.uid == $uid && newData.exists()", ".validate": "newData.isString() && newData.val().length <= 10" },

        // Reject if any other values are set
        "$other": {
          ".validate": false
        }
      }
    },
    "profile": {
      "$uid": {
        // Allow anyone to read
        // Allow user to write data they own
        ".read": "auth.uid != null",

        // Validate inputs
        "locationName": { ".write": "auth.uid == $uid && newData.exists()", ".validate": "newData.isString() && newData.val().length <= 120" },
        "displayName": { ".write": "auth.uid == $uid && newData.exists()", ".validate": "newData.isString() && newData.val().length <= 120" },
        "pictureURL": { ".write": "auth.uid == $uid && newData.exists()", ".validate": "newData.isString() && newData.val().length <= 250 && newData.val().matches(/^https:\\/\\/firebasestorage.googleapis.com\\//i) || newData.val().length == 0" },
        "age": { ".write": "auth.uid == $uid && newData.exists()", ".validate": "newData.isNumber() && newData.val() <= 300 && newData.val() >= 0" },
        "bio": { ".write": "auth.uid == $uid && newData.exists()", ".validate": "newData.isString() && newData.val().length <= 500" },
        "sex": { ".write": "auth.uid == $uid && newData.exists()", ".validate": "newData.isString() && newData.val().length <= 10" },

        // Reject if any other values are set
        "$other": {
          ".validate": false
        }
      }
    },
    "userTags": {
      "$uid": {
        ".read": "auth.uid == $uid",
        "$tagId": {
          // Allow user to write data they own
          ".write": "auth.uid == $uid",

          // New data writes must contain children
          ".validate": "data.exists() || newData.hasChild('name') && newData.hasChild('weight') && newData.hasChild('level') && $tagId.length < 120",

          // Validte inputs
          "weight": { ".validate": "newData.exists() && newData.isNumber() && newData.val() <= 100 && newData.val() >= 0" },
          "level": { ".validate": "newData.exists() && newData.isNumber() && newData.val() <= 10 && newData.val() >= 0" },
          "name": { ".validate": "newData.exists() && newData.isString() && newData.val().length <= 120" },

            // Reject if any other values are set
          "$other": {
            ".validate": false
          }
        }
      }
    },
    "userFollowing": {
      "$uid": {
        ".read": "auth.uid == $uid",
        "$followId": {
          ".write": "auth.uid == $uid",
          ".validate": "newData.isBoolean() && root.child('user').child($followId).exists()"
        }
      }
    },
    "userFollowers": {
      "$uid": {
        ".read": "auth.uid == $uid",
        "$followId": {
          ".write": "auth.uid == $followId",
          ".validate": "newData.isBoolean()"
        }
      }
    },
    // User sets a task to find something
    // Task will dump the results here
    // User will be watching here
    "computed": {
      "$uid": {
        ".read": "auth.uid == $uid",
        ".write": false
      }
    },
    "roomInfo": {
      "$roomId": {
        ".read": "data.child('usersAuth').child(auth.uid).val() == true",
      	".write": false
      }
    },
    "roomChat": {
      "$roomId": {
        ".read": "root.child('roomInfo').child($roomId).child('usersAuth').child(auth.uid).val() == true",
        ".write": false
      }
    },
    // Note anyone can technically write any tag and set the count to any number.
    "tags": {
      ".read": "auth.uid != null",
      "$tagId": {
        ".write": "auth.uid != null",
        ".validate": "newData.isNumber() && newData.val() >= 0 && newData.val() < 10000000000 && $tagId.length < 120"
      }
    },
    // GeoFire
    "geofire": {
      // Don't let anyone to read the GeoFire index
      ".read": false,

      // Index each location's geohash for faster querying
      ".indexOn": ["g"],

      // Schema validation
      "$key": {
        // Allow any authentication user to add or update keys in the GeoFire index
        ".write": "auth.uid === $key && newData.exists()",

        // Key validation
        ".validate": "newData.hasChildren(['g', 'l']) && newData.getPriority().length <= 22 && newData.getPriority().length > 0",

        // Geohash validation
        "g": {
          ".validate": "newData.val() == newData.parent().getPriority()"
        },

        // Location coordinates validation
        "l": {
          "0" : {
            ".validate": "newData.isNumber() && newData.val() >= -90 && newData.val() <= 90"
          },
          "1" : {
            ".validate": "newData.isNumber() && newData.val() >= -180 && newData.val() <= 180"
          },
          "$other": {
            ".validate": false
          }
        },

        // Don't allow any other keys to be written
        "$other": {
          ".validate": false
        }
      }
    },

    // Queue system
    "queue": {
      "tasks": {
        ".read": false,
        ".write": "auth != null",
        ".indexOn": "_state",
        "$taskId": {
          	// Allow user to post if _state is a valid specID
          	// Require _uid to be set to the auth user
          ".validate": "newData.hasChild('_state') && newData.hasChild('_uid')",
          "_state": {
            ".validate": "root.child('queue').child('specs').hasChild(newData.val()) && newData.val() != 'crit' && newData.val() != 'error'"
          },
          "_uid": {
            ".validate": "auth.uid == newData.val()"
          },
            // Optional values
          "watching": {
            ".validate": "newData.isNumber() && newData.val() <= 100000000000000 && newData.val() > 0"
          },
          "list": {
            ".validate": "newData.isString() && newData.val().length <= 10000"
          },
            // Reject anything unspecified above
          "$other": { ".validate": false}
        }
      },
      // Store failed attempts
      "fail": {
        ".read": false,
        ".write": false
      },
      // Store fatal errors
      "crit": {
        ".read": false,
        ".write": false
      },
      // Task models
      "specs" : {
        ".read": false,
        ".write": false,
        // No need to validate if user cannot access
        // This is pretty much just a reference
        "$specId": {
          ".validate": "newData.hasChild('in_progress_state')",
          "start_state": {
            ".validate": "newData.isString()"
          },
          "in_progress_state": {
            ".validate": "newData.isString()"
          },
          "finished_state": {
            ".validate": "newData.isString()"
          },
          "error_state": {
            ".validate": "newData.isString()"
          },
          "timeout": {
            ".validate": "newData.isNumber() && newData.val() > 0"
          },
          "retries": {
            ".validate": "newData.isNumber() && newData.val() >= 0"
          },
          "$other": {
            ".validate": false
          }
        }
      }
    }
  }
}
