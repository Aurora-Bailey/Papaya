{
  "rules": {
    "user": {
      "$uid": {
        // Allow user to access data they own
        ".read": "auth.uid == $uid",
      	".write": "auth.uid == $uid",

        // Validate inputs
        "locationName": { ".validate": "newData.isString() && newData.val().length <= 120" },
        "locationLong": { ".validate": "newData.isNumber() && newData.val() <= 180 && newData.val() >= -180" },
        "locationLat": { ".validate": "newData.isNumber() && newData.val() <= 90 && newData.val() >= -90" },
        "displayName": { ".validate": "newData.isString() && newData.val().length <= 120" },
        "pictureURL": { ".validate": "newData.isString() && newData.val().length <= 250" },
        "firstName": { ".validate": "newData.isString() && newData.val().length <= 60" },
        "lastName": { ".validate": "newData.isString() && newData.val().length <= 60" },
        "distance": { ".validate": "newData.isNumber() && newData.val() <= 100 && newData.val() >= 1" },
        "birthday": { ".validate": "newData.isNumber() && newData.val() <= now && newData.val() >= -5364662000000" },
        // Tighter security, but prevents email change,
        //"email": { ".validate": "auth.token.email == newData.val() || auth.email == newData.val()" },
        "email": { ".validate": "newData.isString() && newData.val().length <= 250" },
        "bio": { ".validate": "newData.isString() && newData.val().length <= 500" },
        "sex": { ".validate": "newData.isString() && newData.val().length <= 10" },

        // Reject if any other values are set
        "$other": {
          ".validate": false
        }
      }
    },
    "roomInfo": {
      "$roomId": {
        ".read": "data.child('usersAuth').child(auth.uid).val() == true",
      	".write": false
      }
    },
    "roomChat": {
      "$roomId": {
        ".read": "root.child('roomInfo').child($roomId).child('usersAuth').child(auth.uid).val() == true",
        ".write": false
      }
    },

    // Queue system
    "queue": {
      "tasks": {
        ".read": false,
        ".write": "auth != null",
        ".indexOn": "_state",
        "$taskId": {
          	// Allow user to post if _state is a valid specID
          	// Require _uid to be set to the auth user
          ".validate": "newData.hasChild('_state') && newData.hasChild('_uid')",
          "_state": {
            ".validate": "root.child('queue').child('specs').hasChild(newData.val())
            							&& newData.val() != 'crit'
            							&& newData.val() != 'error'"
          },
          "_uid": {
            ".validate": "auth.uid == newData.val()" // Custom
          },
            // Reject all other private keys
          "_state_changed": { ".validate": false },
          "_owner": { ".validate": false },
          "_progress": { ".validate": false },
          "_error_details": { ".validate": false },
          "_id": { ".validate": false }
        }
      },
      "fail": {
        ".read": false,
        ".write": false
      },
      "specs" : {
        ".read": false,
        ".write": false,
        // No need to validate if user cannot access
        // This is pretty much just a reference
        "$specId": {
          ".validate": "newData.hasChild('in_progress_state')",
          "start_state": {
            ".validate": "newData.isString()"
          },
          "in_progress_state": {
            ".validate": "newData.isString()"
          },
          "finished_state": {
            ".validate": "newData.isString()"
          },
          "error_state": {
            ".validate": "newData.isString()"
          },
          "timeout": {
            ".validate": "newData.isNumber() && newData.val() > 0"
          },
          "retries": {
            ".validate": "newData.isNumber() && newData.val() >= 0"
          },
          "$other": {
            ".validate": false
          }
        }
      }
    }
  }
}
